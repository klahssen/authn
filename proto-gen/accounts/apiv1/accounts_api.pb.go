// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: accounts/v1/accounts_api.proto

package apiv1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//AccountStatus is an authorization criteria
type AccountStatus int32

const (
	AccountStatus_CREATED  AccountStatus = 0
	AccountStatus_ACTIVE   AccountStatus = 1
	AccountStatus_LOCKED   AccountStatus = 2
	AccountStatus_INACTIVE AccountStatus = 3
	AccountStatus_DELETED  AccountStatus = 4
)

var AccountStatus_name = map[int32]string{
	0: "CREATED",
	1: "ACTIVE",
	2: "LOCKED",
	3: "INACTIVE",
	4: "DELETED",
}

var AccountStatus_value = map[string]int32{
	"CREATED":  0,
	"ACTIVE":   1,
	"LOCKED":   2,
	"INACTIVE": 3,
	"DELETED":  4,
}

func (x AccountStatus) String() string {
	return proto.EnumName(AccountStatus_name, int32(x))
}

func (AccountStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{0}
}

type IDType int32

const (
	IDType_UID   IDType = 0
	IDType_EMAIL IDType = 1
)

var IDType_name = map[int32]string{
	0: "UID",
	1: "EMAIL",
}

var IDType_value = map[string]int32{
	"UID":   0,
	"EMAIL": 1,
}

func (x IDType) String() string {
	return proto.EnumName(IDType_name, int32(x))
}

func (IDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{1}
}

//Account(timestamps in seconds)
type Account struct {
	// `datastore:"-"`
	Uid           string        `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid" db:"uid"`
	Email         string        `protobuf:"bytes,3,opt,name=email,proto3" json:"email" db:"email"`
	Hash          string        `protobuf:"bytes,4,opt,name=hash,json=-,proto3" json:"-" db:"hash"`
	CreatedAt     int64         `protobuf:"varint,5,opt,name=created_at,json=crea,proto3" json:"crea" db:"crea"`
	UpdatedAt     int64         `protobuf:"varint,6,opt,name=updated_at,json=upd,proto3" json:"upd" db:"upd"`
	Roles         []string      `protobuf:"bytes,7,rep,name=roles,proto3" json:"roles" db:"roles"`
	Status        AccountStatus `protobuf:"varint,8,opt,name=status,proto3,enum=authn.accounts.v1.AccountStatus" json:"status" db:"status"`
	ParentAccount string        `protobuf:"bytes,9,opt,name=parent_account,json=parent,proto3" json:"parent" db:"parent"`
}

func (m *Account) Reset()         { *m = Account{} }
func (m *Account) String() string { return proto.CompactTextString(m) }
func (*Account) ProtoMessage()    {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{0}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Account) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Account) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Account) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Account) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *Account) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *Account) GetStatus() AccountStatus {
	if m != nil {
		return m.Status
	}
	return AccountStatus_CREATED
}

func (m *Account) GetParentAccount() string {
	if m != nil {
		return m.ParentAccount
	}
	return ""
}

type Info struct {
	Type   string        `protobuf:"bytes,1,opt,name=type,proto3" json:"type" db:"type"`
	Uid    string        `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid" db:"uid"`
	Status AccountStatus `protobuf:"varint,3,opt,name=status,proto3,enum=authn.accounts.v1.AccountStatus" json:"status" db:"status"`
	Roles  []string      `protobuf:"bytes,4,rep,name=roles,proto3" json:"roles" db:"roles"`
}

func (m *Info) Reset()         { *m = Info{} }
func (m *Info) String() string { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()    {}
func (*Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{1}
}
func (m *Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Info.Merge(m, src)
}
func (m *Info) XXX_Size() int {
	return m.Size()
}
func (m *Info) XXX_DiscardUnknown() {
	xxx_messageInfo_Info.DiscardUnknown(m)
}

var xxx_messageInfo_Info proto.InternalMessageInfo

func (m *Info) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Info) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *Info) GetStatus() AccountStatus {
	if m != nil {
		return m.Status
	}
	return AccountStatus_CREATED
}

func (m *Info) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

type MultiAccounts struct {
	Accounts []*Account `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts" db:"accounts"`
}

func (m *MultiAccounts) Reset()         { *m = MultiAccounts{} }
func (m *MultiAccounts) String() string { return proto.CompactTextString(m) }
func (*MultiAccounts) ProtoMessage()    {}
func (*MultiAccounts) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{2}
}
func (m *MultiAccounts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiAccounts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiAccounts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiAccounts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiAccounts.Merge(m, src)
}
func (m *MultiAccounts) XXX_Size() int {
	return m.Size()
}
func (m *MultiAccounts) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiAccounts.DiscardUnknown(m)
}

var xxx_messageInfo_MultiAccounts proto.InternalMessageInfo

func (m *MultiAccounts) GetAccounts() []*Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type AccountID struct {
	Id   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type IDType `protobuf:"varint,2,opt,name=type,proto3,enum=authn.accounts.v1.IDType" json:"type,omitempty"`
}

func (m *AccountID) Reset()         { *m = AccountID{} }
func (m *AccountID) String() string { return proto.CompactTextString(m) }
func (*AccountID) ProtoMessage()    {}
func (*AccountID) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{3}
}
func (m *AccountID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountID.Merge(m, src)
}
func (m *AccountID) XXX_Size() int {
	return m.Size()
}
func (m *AccountID) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountID.DiscardUnknown(m)
}

var xxx_messageInfo_AccountID proto.InternalMessageInfo

func (m *AccountID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AccountID) GetType() IDType {
	if m != nil {
		return m.Type
	}
	return IDType_UID
}

type AccountIDs struct {
	Ids  []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
	Type IDType   `protobuf:"varint,2,opt,name=type,proto3,enum=authn.accounts.v1.IDType" json:"type,omitempty"`
}

func (m *AccountIDs) Reset()         { *m = AccountIDs{} }
func (m *AccountIDs) String() string { return proto.CompactTextString(m) }
func (*AccountIDs) ProtoMessage()    {}
func (*AccountIDs) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{4}
}
func (m *AccountIDs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountIDs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountIDs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountIDs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountIDs.Merge(m, src)
}
func (m *AccountIDs) XXX_Size() int {
	return m.Size()
}
func (m *AccountIDs) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountIDs.DiscardUnknown(m)
}

var xxx_messageInfo_AccountIDs proto.InternalMessageInfo

func (m *AccountIDs) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *AccountIDs) GetType() IDType {
	if m != nil {
		return m.Type
	}
	return IDType_UID
}

//AccountParams holds payload to create/update an Account
type AccountParams struct {
	Uid    string `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Email  string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Pwd    string `protobuf:"bytes,3,opt,name=pwd,proto3" json:"pwd,omitempty"`
	Parent string `protobuf:"bytes,4,opt,name=parent,proto3" json:"parent,omitempty"`
}

func (m *AccountParams) Reset()         { *m = AccountParams{} }
func (m *AccountParams) String() string { return proto.CompactTextString(m) }
func (*AccountParams) ProtoMessage()    {}
func (*AccountParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{5}
}
func (m *AccountParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountParams.Merge(m, src)
}
func (m *AccountParams) XXX_Size() int {
	return m.Size()
}
func (m *AccountParams) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountParams.DiscardUnknown(m)
}

var xxx_messageInfo_AccountParams proto.InternalMessageInfo

func (m *AccountParams) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *AccountParams) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *AccountParams) GetPwd() string {
	if m != nil {
		return m.Pwd
	}
	return ""
}

func (m *AccountParams) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

//AccountPrivilege holds to add or remove a role from an account
type AccountPrivileges struct {
	Uid    string        `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Roles  []string      `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	Status AccountStatus `protobuf:"varint,3,opt,name=status,proto3,enum=authn.accounts.v1.AccountStatus" json:"status,omitempty"`
}

func (m *AccountPrivileges) Reset()         { *m = AccountPrivileges{} }
func (m *AccountPrivileges) String() string { return proto.CompactTextString(m) }
func (*AccountPrivileges) ProtoMessage()    {}
func (*AccountPrivileges) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{6}
}
func (m *AccountPrivileges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountPrivileges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountPrivileges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountPrivileges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountPrivileges.Merge(m, src)
}
func (m *AccountPrivileges) XXX_Size() int {
	return m.Size()
}
func (m *AccountPrivileges) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountPrivileges.DiscardUnknown(m)
}

var xxx_messageInfo_AccountPrivileges proto.InternalMessageInfo

func (m *AccountPrivileges) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *AccountPrivileges) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *AccountPrivileges) GetStatus() AccountStatus {
	if m != nil {
		return m.Status
	}
	return AccountStatus_CREATED
}

//JwtAuthTokens holds authentication tokens
type JwtAuthTokens struct {
	Access  string `protobuf:"bytes,1,opt,name=access,proto3" json:"access,omitempty"`
	Refresh string `protobuf:"bytes,2,opt,name=refresh,proto3" json:"refresh,omitempty"`
}

func (m *JwtAuthTokens) Reset()         { *m = JwtAuthTokens{} }
func (m *JwtAuthTokens) String() string { return proto.CompactTextString(m) }
func (*JwtAuthTokens) ProtoMessage()    {}
func (*JwtAuthTokens) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{7}
}
func (m *JwtAuthTokens) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JwtAuthTokens) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JwtAuthTokens.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JwtAuthTokens) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JwtAuthTokens.Merge(m, src)
}
func (m *JwtAuthTokens) XXX_Size() int {
	return m.Size()
}
func (m *JwtAuthTokens) XXX_DiscardUnknown() {
	xxx_messageInfo_JwtAuthTokens.DiscardUnknown(m)
}

var xxx_messageInfo_JwtAuthTokens proto.InternalMessageInfo

func (m *JwtAuthTokens) GetAccess() string {
	if m != nil {
		return m.Access
	}
	return ""
}

func (m *JwtAuthTokens) GetRefresh() string {
	if m != nil {
		return m.Refresh
	}
	return ""
}

//Credentials holds credentials to authenticate a user
type Credentials struct {
	Id  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Pwd string `protobuf:"bytes,2,opt,name=pwd,proto3" json:"pwd,omitempty"`
}

func (m *Credentials) Reset()         { *m = Credentials{} }
func (m *Credentials) String() string { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()    {}
func (*Credentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{8}
}
func (m *Credentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Credentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Credentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Credentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Credentials.Merge(m, src)
}
func (m *Credentials) XXX_Size() int {
	return m.Size()
}
func (m *Credentials) XXX_DiscardUnknown() {
	xxx_messageInfo_Credentials.DiscardUnknown(m)
}

var xxx_messageInfo_Credentials proto.InternalMessageInfo

func (m *Credentials) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Credentials) GetPwd() string {
	if m != nil {
		return m.Pwd
	}
	return ""
}

type PutAccountParams struct {
	Uid  string   `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Acct *Account `protobuf:"bytes,2,opt,name=acct,proto3" json:"acct,omitempty"`
}

func (m *PutAccountParams) Reset()         { *m = PutAccountParams{} }
func (m *PutAccountParams) String() string { return proto.CompactTextString(m) }
func (*PutAccountParams) ProtoMessage()    {}
func (*PutAccountParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b32f31c7eac1477, []int{9}
}
func (m *PutAccountParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutAccountParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutAccountParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutAccountParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutAccountParams.Merge(m, src)
}
func (m *PutAccountParams) XXX_Size() int {
	return m.Size()
}
func (m *PutAccountParams) XXX_DiscardUnknown() {
	xxx_messageInfo_PutAccountParams.DiscardUnknown(m)
}

var xxx_messageInfo_PutAccountParams proto.InternalMessageInfo

func (m *PutAccountParams) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *PutAccountParams) GetAcct() *Account {
	if m != nil {
		return m.Acct
	}
	return nil
}

func init() {
	proto.RegisterEnum("authn.accounts.v1.AccountStatus", AccountStatus_name, AccountStatus_value)
	proto.RegisterEnum("authn.accounts.v1.IDType", IDType_name, IDType_value)
	proto.RegisterType((*Account)(nil), "authn.accounts.v1.Account")
	proto.RegisterType((*Info)(nil), "authn.accounts.v1.Info")
	proto.RegisterType((*MultiAccounts)(nil), "authn.accounts.v1.MultiAccounts")
	proto.RegisterType((*AccountID)(nil), "authn.accounts.v1.AccountID")
	proto.RegisterType((*AccountIDs)(nil), "authn.accounts.v1.AccountIDs")
	proto.RegisterType((*AccountParams)(nil), "authn.accounts.v1.AccountParams")
	proto.RegisterType((*AccountPrivileges)(nil), "authn.accounts.v1.AccountPrivileges")
	proto.RegisterType((*JwtAuthTokens)(nil), "authn.accounts.v1.JwtAuthTokens")
	proto.RegisterType((*Credentials)(nil), "authn.accounts.v1.Credentials")
	proto.RegisterType((*PutAccountParams)(nil), "authn.accounts.v1.PutAccountParams")
}

func init() { proto.RegisterFile("accounts/v1/accounts_api.proto", fileDescriptor_3b32f31c7eac1477) }

var fileDescriptor_3b32f31c7eac1477 = []byte{
	// 971 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0x36, 0x45, 0xfd, 0x1d, 0xc5, 0x86, 0xb2, 0xbf, 0x5f, 0x5b, 0x45, 0x48, 0x44, 0x81, 0x69,
	0x01, 0x37, 0xa8, 0x24, 0x58, 0xbd, 0xb4, 0xbd, 0x14, 0x92, 0x28, 0xa4, 0x8c, 0xff, 0x44, 0xa5,
	0xe5, 0x1e, 0x7a, 0x31, 0xd6, 0xe2, 0x5a, 0x22, 0x22, 0x93, 0x04, 0xb9, 0x94, 0xe1, 0xb7, 0xe8,
	0x33, 0xf4, 0x45, 0x7a, 0xed, 0xd1, 0xc7, 0x1e, 0x0a, 0xa2, 0xb0, 0x6f, 0x3a, 0xea, 0x09, 0x8a,
	0xdd, 0xe5, 0x32, 0x49, 0x23, 0x4b, 0x09, 0xec, 0xdb, 0xce, 0xec, 0xcc, 0xb7, 0xb3, 0xdf, 0x7c,
	0x43, 0x2e, 0xd4, 0xf1, 0x78, 0xec, 0x45, 0x2e, 0x0d, 0xdb, 0xf3, 0xbd, 0xb6, 0x5c, 0x9f, 0x62,
	0xdf, 0x69, 0xf9, 0x81, 0x47, 0x3d, 0xf4, 0x18, 0x47, 0x74, 0xea, 0xb6, 0xe4, 0x4e, 0x6b, 0xbe,
	0x57, 0x6b, 0x4e, 0x1c, 0x3a, 0x8d, 0xce, 0x5a, 0x63, 0xef, 0xa2, 0x3d, 0xf1, 0x26, 0x5e, 0x9b,
	0x47, 0x9e, 0x45, 0xe7, 0xdc, 0xe2, 0x06, 0x5f, 0x09, 0x04, 0xfd, 0x77, 0x15, 0x0a, 0x5d, 0x91,
	0x8e, 0xbe, 0x02, 0x35, 0x72, 0xec, 0xaa, 0xd2, 0x50, 0x76, 0x4b, 0xbd, 0xff, 0x2d, 0x62, 0x8d,
	0x99, 0xcb, 0x58, 0x2b, 0xda, 0x67, 0x3f, 0xe8, 0x91, 0x63, 0xeb, 0x16, 0x73, 0xa0, 0x26, 0xe4,
	0xc8, 0x05, 0x76, 0x66, 0x55, 0x95, 0x07, 0x7e, 0xb1, 0x88, 0x35, 0xe1, 0x58, 0xc6, 0x1a, 0xb0,
	0x50, 0x6e, 0xe8, 0x96, 0x70, 0xa2, 0xe7, 0x90, 0x9d, 0xe2, 0x70, 0x5a, 0xcd, 0xf2, 0x68, 0xb4,
	0x88, 0x35, 0xa5, 0xb9, 0x8c, 0xb5, 0x12, 0x8b, 0x64, 0x1b, 0xba, 0xa5, 0x34, 0x51, 0x1b, 0x60,
	0x1c, 0x10, 0x4c, 0x89, 0x7d, 0x8a, 0x69, 0x35, 0xd7, 0x50, 0x76, 0xd5, 0xde, 0x67, 0x8b, 0x58,
	0xcb, 0x32, 0xaf, 0x8c, 0x66, 0x6b, 0xdd, 0xe2, 0x2e, 0xf4, 0x0d, 0x40, 0xe4, 0xdb, 0x32, 0x21,
	0xcf, 0x13, 0x44, 0xc9, 0xfe, 0xdb, 0x92, 0x7d, 0x5e, 0xb2, 0xcf, 0x4b, 0x0e, 0xbc, 0x19, 0x09,
	0xab, 0x85, 0x86, 0x2a, 0x4b, 0xe6, 0x0e, 0x59, 0x32, 0x37, 0x74, 0x4b, 0x38, 0xd1, 0x31, 0xe4,
	0x43, 0x8a, 0x69, 0x14, 0x56, 0x8b, 0x0d, 0x65, 0x77, 0xa7, 0xd3, 0x68, 0x7d, 0xc0, 0x73, 0x2b,
	0x21, 0xed, 0x98, 0xc7, 0xf5, 0x9e, 0x2c, 0x62, 0x2d, 0xc9, 0x59, 0xc6, 0x5a, 0x99, 0x41, 0x0a,
	0x4b, 0xb7, 0x12, 0x37, 0xfa, 0x1e, 0x76, 0x7c, 0x1c, 0x10, 0x97, 0x9e, 0x26, 0x30, 0xd5, 0x12,
	0x67, 0x84, 0xa7, 0x8a, 0x1d, 0x99, 0x2a, 0x2c, 0xdd, 0x4a, 0xdc, 0xfa, 0xdf, 0x0a, 0x64, 0x4d,
	0xf7, 0xdc, 0x43, 0x5f, 0x43, 0x96, 0x5e, 0xf9, 0x24, 0x69, 0x11, 0x27, 0x88, 0xd9, 0x92, 0x20,
	0xb6, 0xd6, 0x2d, 0xee, 0x92, 0xcd, 0xcc, 0x6c, 0x68, 0xe6, 0xdb, 0xab, 0xaa, 0x0f, 0x77, 0xd5,
	0x94, 0xee, 0xec, 0xc7, 0xd0, 0xad, 0x9f, 0xc3, 0xf6, 0x61, 0x34, 0xa3, 0x4e, 0x72, 0x4e, 0x88,
	0x4e, 0xa0, 0x28, 0xcf, 0xaf, 0x2a, 0x0d, 0x75, 0xb7, 0xdc, 0xa9, 0xdd, 0x5d, 0x56, 0xef, 0xd9,
	0x22, 0xd6, 0xd2, 0xf8, 0x65, 0xac, 0x6d, 0xb3, 0x13, 0xa4, 0xad, 0x5b, 0xe9, 0x96, 0xfe, 0x0a,
	0x4a, 0x49, 0x8e, 0x69, 0xa0, 0x1d, 0xc8, 0x48, 0xad, 0x5b, 0x19, 0xae, 0x6a, 0x41, 0x6d, 0x86,
	0xd3, 0xf0, 0x64, 0xc5, 0x79, 0xa6, 0x31, 0xba, 0xf2, 0x89, 0xa0, 0x57, 0x3f, 0x04, 0x48, 0xb1,
	0x42, 0x54, 0x01, 0xd5, 0xb1, 0x45, 0xad, 0x25, 0x8b, 0x2d, 0x3f, 0x15, 0x0e, 0xc3, 0x76, 0x02,
	0x37, 0xc4, 0x01, 0xbe, 0xe0, 0x88, 0xe9, 0x2c, 0x8a, 0x4e, 0xfd, 0x5f, 0x8e, 0x1d, 0x6f, 0xa9,
	0x9c, 0xae, 0x0a, 0xa8, 0xfe, 0xa5, 0x2d, 0x46, 0xd1, 0x62, 0x4b, 0xf4, 0x39, 0x24, 0xb2, 0x11,
	0x13, 0x97, 0x8a, 0x28, 0x82, 0xc7, 0xf2, 0x88, 0xc0, 0x99, 0x3b, 0x33, 0x32, 0x21, 0x77, 0x1c,
	0x23, 0x7a, 0x97, 0xe1, 0x97, 0x49, 0x26, 0xe2, 0xbb, 0x4f, 0x95, 0x89, 0xd4, 0x82, 0xde, 0x85,
	0xed, 0x57, 0x97, 0xb4, 0x1b, 0xd1, 0xe9, 0xc8, 0x7b, 0x43, 0xdc, 0x90, 0xd5, 0x87, 0xc7, 0x63,
	0x12, 0x86, 0xc9, 0xa9, 0x89, 0x85, 0xaa, 0x50, 0x08, 0xc8, 0x79, 0x40, 0xc2, 0x69, 0x72, 0x43,
	0x69, 0xea, 0x6d, 0x28, 0xf7, 0x03, 0x62, 0x13, 0x97, 0x3a, 0x78, 0x16, 0x7e, 0xd0, 0xb9, 0x84,
	0x82, 0x4c, 0x4a, 0x81, 0x3e, 0x82, 0xca, 0x30, 0xa2, 0x9b, 0x08, 0x6d, 0x41, 0x16, 0x8f, 0xc7,
	0x94, 0x27, 0xae, 0x55, 0x98, 0xc5, 0xe3, 0x5e, 0xbc, 0x4e, 0x7b, 0x24, 0xae, 0x88, 0xca, 0x50,
	0xe8, 0x5b, 0x83, 0xee, 0x68, 0x60, 0x54, 0xb6, 0x10, 0x40, 0xbe, 0xdb, 0x1f, 0x99, 0xbf, 0x0c,
	0x2a, 0x0a, 0x5b, 0x1f, 0xbc, 0xee, 0xef, 0x0f, 0x8c, 0x4a, 0x06, 0x3d, 0x82, 0xa2, 0x79, 0x94,
	0xec, 0xa8, 0x2c, 0xc5, 0x18, 0x1c, 0x0c, 0x58, 0x4a, 0xf6, 0xc5, 0x53, 0xc8, 0x0b, 0x11, 0xa0,
	0x02, 0xa8, 0x27, 0x26, 0x43, 0x29, 0x41, 0x6e, 0x70, 0xd8, 0x35, 0x0f, 0x2a, 0x4a, 0xe7, 0x3a,
	0x07, 0x65, 0x39, 0x11, 0xdd, 0xa1, 0x89, 0x7e, 0x82, 0x7c, 0x9f, 0x7f, 0x22, 0xd1, 0x1a, 0xf2,
	0xc5, 0x65, 0x6b, 0x4f, 0xef, 0x8e, 0x30, 0x0d, 0x74, 0x08, 0xe5, 0x13, 0xfe, 0xed, 0x1c, 0x70,
	0x09, 0xdd, 0x17, 0x6e, 0x08, 0x3b, 0x02, 0x6e, 0x88, 0xc3, 0xf0, 0xd2, 0x0b, 0xec, 0x7b, 0x23,
	0x1e, 0x41, 0xb1, 0x6b, 0xdb, 0x16, 0x57, 0xde, 0x97, 0x6b, 0xb0, 0x52, 0x1d, 0x6f, 0xc0, 0xfb,
	0x19, 0xca, 0x16, 0xb9, 0xf0, 0xe6, 0xe4, 0xe1, 0x20, 0x8f, 0xa0, 0x78, 0x4c, 0xe8, 0xc3, 0xe1,
	0x59, 0xf0, 0x48, 0x90, 0x98, 0x68, 0xeb, 0x21, 0x30, 0x0d, 0x28, 0xbe, 0x24, 0xb4, 0x77, 0x75,
	0x62, 0x1a, 0x68, 0x6d, 0x64, 0x6d, 0x8d, 0xf8, 0x91, 0x09, 0x39, 0x36, 0xbd, 0x2e, 0xaa, 0xaf,
	0x08, 0x7a, 0x67, 0x2e, 0x6b, 0xab, 0xba, 0xfe, 0xde, 0xe8, 0x77, 0xfe, 0x50, 0x53, 0x49, 0x5b,
	0xc4, 0xf7, 0x50, 0x0f, 0xf2, 0xa6, 0x1b, 0x92, 0x80, 0xa2, 0x35, 0x05, 0x6c, 0xb8, 0xe4, 0x3e,
	0xe4, 0x05, 0x71, 0xe8, 0xf9, 0x8a, 0xb8, 0xff, 0x7e, 0x06, 0x36, 0x80, 0xfd, 0x08, 0xea, 0x4b,
	0x42, 0xef, 0x41, 0xd6, 0x3e, 0xa7, 0x9c, 0xff, 0xcd, 0xd0, 0xb3, 0x75, 0x28, 0xab, 0xe9, 0x7a,
	0xff, 0x37, 0x68, 0x40, 0xde, 0x20, 0x33, 0x42, 0xc9, 0x86, 0x82, 0x36, 0x11, 0x54, 0x16, 0x28,
	0x1f, 0x55, 0xd5, 0xfa, 0xed, 0xde, 0xc1, 0x9f, 0x37, 0x75, 0xe5, 0xfa, 0xa6, 0xae, 0xfc, 0x73,
	0x53, 0x57, 0x7e, 0xbb, 0xad, 0x6f, 0x5d, 0xdf, 0xd6, 0xb7, 0xfe, 0xba, 0xad, 0x6f, 0xfd, 0xda,
	0x79, 0xe7, 0xdd, 0xf9, 0x66, 0x86, 0xa7, 0x61, 0x48, 0xdc, 0x36, 0xc7, 0x12, 0x2f, 0xd0, 0xe6,
	0x84, 0xd9, 0xf2, 0x39, 0x8b, 0x7d, 0x67, 0xbe, 0x77, 0x96, 0xe7, 0x3b, 0xdf, 0xfe, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x49, 0xb3, 0x23, 0x40, 0xe7, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AccountsAPIClient is the client API for AccountsAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccountsAPIClient interface {
	Create(ctx context.Context, in *AccountParams, opts ...grpc.CallOption) (*AccountID, error)
	UpdateEmail(ctx context.Context, in *AccountParams, opts ...grpc.CallOption) (*AccountID, error)
	UpdatePassword(ctx context.Context, in *AccountParams, opts ...grpc.CallOption) (*AccountID, error)
	AddRoles(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error)
	RemoveRoles(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error)
	SetRoles(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error)
	UpdateStatus(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error)
	GetByUID(ctx context.Context, in *AccountID, opts ...grpc.CallOption) (*Account, error)
	Authn(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JwtAuthTokens, error)
}

type accountsAPIClient struct {
	cc *grpc.ClientConn
}

func NewAccountsAPIClient(cc *grpc.ClientConn) AccountsAPIClient {
	return &accountsAPIClient{cc}
}

func (c *accountsAPIClient) Create(ctx context.Context, in *AccountParams, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) UpdateEmail(ctx context.Context, in *AccountParams, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/UpdateEmail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) UpdatePassword(ctx context.Context, in *AccountParams, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/UpdatePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) AddRoles(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/AddRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) RemoveRoles(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/RemoveRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) SetRoles(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/SetRoles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) UpdateStatus(ctx context.Context, in *AccountPrivileges, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/UpdateStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) GetByUID(ctx context.Context, in *AccountID, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/GetByUID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsAPIClient) Authn(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JwtAuthTokens, error) {
	out := new(JwtAuthTokens)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountsAPI/Authn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountsAPIServer is the server API for AccountsAPI service.
type AccountsAPIServer interface {
	Create(context.Context, *AccountParams) (*AccountID, error)
	UpdateEmail(context.Context, *AccountParams) (*AccountID, error)
	UpdatePassword(context.Context, *AccountParams) (*AccountID, error)
	AddRoles(context.Context, *AccountPrivileges) (*AccountID, error)
	RemoveRoles(context.Context, *AccountPrivileges) (*AccountID, error)
	SetRoles(context.Context, *AccountPrivileges) (*AccountID, error)
	UpdateStatus(context.Context, *AccountPrivileges) (*AccountID, error)
	GetByUID(context.Context, *AccountID) (*Account, error)
	Authn(context.Context, *Credentials) (*JwtAuthTokens, error)
}

func RegisterAccountsAPIServer(s *grpc.Server, srv AccountsAPIServer) {
	s.RegisterService(&_AccountsAPI_serviceDesc, srv)
}

func _AccountsAPI_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).Create(ctx, req.(*AccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_UpdateEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).UpdateEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/UpdateEmail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).UpdateEmail(ctx, req.(*AccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).UpdatePassword(ctx, req.(*AccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_AddRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountPrivileges)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).AddRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/AddRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).AddRoles(ctx, req.(*AccountPrivileges))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_RemoveRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountPrivileges)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).RemoveRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/RemoveRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).RemoveRoles(ctx, req.(*AccountPrivileges))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_SetRoles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountPrivileges)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).SetRoles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/SetRoles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).SetRoles(ctx, req.(*AccountPrivileges))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountPrivileges)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/UpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).UpdateStatus(ctx, req.(*AccountPrivileges))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_GetByUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).GetByUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/GetByUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).GetByUID(ctx, req.(*AccountID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountsAPI_Authn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountsAPIServer).Authn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountsAPI/Authn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountsAPIServer).Authn(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccountsAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "authn.accounts.v1.AccountsAPI",
	HandlerType: (*AccountsAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _AccountsAPI_Create_Handler,
		},
		{
			MethodName: "UpdateEmail",
			Handler:    _AccountsAPI_UpdateEmail_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _AccountsAPI_UpdatePassword_Handler,
		},
		{
			MethodName: "AddRoles",
			Handler:    _AccountsAPI_AddRoles_Handler,
		},
		{
			MethodName: "RemoveRoles",
			Handler:    _AccountsAPI_RemoveRoles_Handler,
		},
		{
			MethodName: "SetRoles",
			Handler:    _AccountsAPI_SetRoles_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _AccountsAPI_UpdateStatus_Handler,
		},
		{
			MethodName: "GetByUID",
			Handler:    _AccountsAPI_GetByUID_Handler,
		},
		{
			MethodName: "Authn",
			Handler:    _AccountsAPI_Authn_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accounts/v1/accounts_api.proto",
}

// AccountRepoClient is the client API for AccountRepo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccountRepoClient interface {
	Insert(ctx context.Context, in *Account, opts ...grpc.CallOption) (*AccountID, error)
	Update(ctx context.Context, in *PutAccountParams, opts ...grpc.CallOption) (*AccountID, error)
	Get(ctx context.Context, in *AccountID, opts ...grpc.CallOption) (*Account, error)
	GetMulti(ctx context.Context, in *AccountIDs, opts ...grpc.CallOption) (*MultiAccounts, error)
	Delete(ctx context.Context, in *AccountID, opts ...grpc.CallOption) (*AccountID, error)
	DeleteMulti(ctx context.Context, in *AccountIDs, opts ...grpc.CallOption) (*AccountIDs, error)
}

type accountRepoClient struct {
	cc *grpc.ClientConn
}

func NewAccountRepoClient(cc *grpc.ClientConn) AccountRepoClient {
	return &accountRepoClient{cc}
}

func (c *accountRepoClient) Insert(ctx context.Context, in *Account, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountRepo/Insert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRepoClient) Update(ctx context.Context, in *PutAccountParams, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountRepo/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRepoClient) Get(ctx context.Context, in *AccountID, opts ...grpc.CallOption) (*Account, error) {
	out := new(Account)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountRepo/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRepoClient) GetMulti(ctx context.Context, in *AccountIDs, opts ...grpc.CallOption) (*MultiAccounts, error) {
	out := new(MultiAccounts)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountRepo/GetMulti", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRepoClient) Delete(ctx context.Context, in *AccountID, opts ...grpc.CallOption) (*AccountID, error) {
	out := new(AccountID)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountRepo/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountRepoClient) DeleteMulti(ctx context.Context, in *AccountIDs, opts ...grpc.CallOption) (*AccountIDs, error) {
	out := new(AccountIDs)
	err := c.cc.Invoke(ctx, "/authn.accounts.v1.AccountRepo/DeleteMulti", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountRepoServer is the server API for AccountRepo service.
type AccountRepoServer interface {
	Insert(context.Context, *Account) (*AccountID, error)
	Update(context.Context, *PutAccountParams) (*AccountID, error)
	Get(context.Context, *AccountID) (*Account, error)
	GetMulti(context.Context, *AccountIDs) (*MultiAccounts, error)
	Delete(context.Context, *AccountID) (*AccountID, error)
	DeleteMulti(context.Context, *AccountIDs) (*AccountIDs, error)
}

func RegisterAccountRepoServer(s *grpc.Server, srv AccountRepoServer) {
	s.RegisterService(&_AccountRepo_serviceDesc, srv)
}

func _AccountRepo_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Account)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRepoServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountRepo/Insert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRepoServer).Insert(ctx, req.(*Account))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRepo_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutAccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRepoServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountRepo/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRepoServer).Update(ctx, req.(*PutAccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRepo_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRepoServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountRepo/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRepoServer).Get(ctx, req.(*AccountID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRepo_GetMulti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountIDs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRepoServer).GetMulti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountRepo/GetMulti",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRepoServer).GetMulti(ctx, req.(*AccountIDs))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRepo_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRepoServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountRepo/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRepoServer).Delete(ctx, req.(*AccountID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountRepo_DeleteMulti_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountIDs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountRepoServer).DeleteMulti(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authn.accounts.v1.AccountRepo/DeleteMulti",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountRepoServer).DeleteMulti(ctx, req.(*AccountIDs))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccountRepo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "authn.accounts.v1.AccountRepo",
	HandlerType: (*AccountRepoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Insert",
			Handler:    _AccountRepo_Insert_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _AccountRepo_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AccountRepo_Get_Handler,
		},
		{
			MethodName: "GetMulti",
			Handler:    _AccountRepo_GetMulti_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _AccountRepo_Delete_Handler,
		},
		{
			MethodName: "DeleteMulti",
			Handler:    _AccountRepo_DeleteMulti_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accounts/v1/accounts_api.proto",
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.UpdatedAt))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.Status))
	}
	if len(m.ParentAccount) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.ParentAccount)))
		i += copy(dAtA[i:], m.ParentAccount)
	}
	return i, nil
}

func (m *Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Info) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.Status))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *MultiAccounts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiAccounts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, msg := range m.Accounts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccountsApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AccountID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *AccountIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountIDs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *AccountParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Pwd) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Pwd)))
		i += copy(dAtA[i:], m.Pwd)
	}
	if len(m.Parent) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Parent)))
		i += copy(dAtA[i:], m.Parent)
	}
	return i, nil
}

func (m *AccountPrivileges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountPrivileges) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Status != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *JwtAuthTokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JwtAuthTokens) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Access) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Access)))
		i += copy(dAtA[i:], m.Access)
	}
	if len(m.Refresh) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Refresh)))
		i += copy(dAtA[i:], m.Refresh)
	}
	return i, nil
}

func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Pwd) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Pwd)))
		i += copy(dAtA[i:], m.Pwd)
	}
	return i, nil
}

func (m *PutAccountParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutAccountParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if m.Acct != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccountsApi(dAtA, i, uint64(m.Acct.Size()))
		n1, err := m.Acct.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func encodeVarintAccountsApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovAccountsApi(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovAccountsApi(uint64(m.UpdatedAt))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAccountsApi(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAccountsApi(uint64(m.Status))
	}
	l = len(m.ParentAccount)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	return n
}

func (m *Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAccountsApi(uint64(m.Status))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAccountsApi(uint64(l))
		}
	}
	return n
}

func (m *MultiAccounts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovAccountsApi(uint64(l))
		}
	}
	return n
}

func (m *AccountID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAccountsApi(uint64(m.Type))
	}
	return n
}

func (m *AccountIDs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			l = len(s)
			n += 1 + l + sovAccountsApi(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovAccountsApi(uint64(m.Type))
	}
	return n
}

func (m *AccountParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Pwd)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	return n
}

func (m *AccountPrivileges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAccountsApi(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovAccountsApi(uint64(m.Status))
	}
	return n
}

func (m *JwtAuthTokens) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Access)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Refresh)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	return n
}

func (m *Credentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	l = len(m.Pwd)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	return n
}

func (m *PutAccountParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	if m.Acct != nil {
		l = m.Acct.Size()
		n += 1 + l + sovAccountsApi(uint64(l))
	}
	return n
}

func sovAccountsApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAccountsApi(x uint64) (n int) {
	return sovAccountsApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiAccounts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiAccounts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiAccounts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &Account{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= IDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountPrivileges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountPrivileges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountPrivileges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JwtAuthTokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JwtAuthTokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JwtAuthTokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Access = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refresh", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refresh = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutAccountParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutAccountParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutAccountParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccountsApi
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acct == nil {
				m.Acct = &Account{}
			}
			if err := m.Acct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccountsApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAccountsApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccountsApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccountsApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccountsApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAccountsApi
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthAccountsApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAccountsApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAccountsApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthAccountsApi
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAccountsApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccountsApi   = fmt.Errorf("proto: integer overflow")
)
